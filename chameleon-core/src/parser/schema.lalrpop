use crate::ast::*;
use std::collections::HashMap;

grammar;

// Whitespace y comentarios
match {
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    _
}

// Punto de entrada
pub Schema: Schema = {
    <entities:Entity*> => {
        let mut schema = Schema::new();
        for entity in entities {
            schema.add_entity(entity);
        }
        schema
    }
};

// Entity definition
Entity: Entity = {
    "entity" <name:Ident> "{" <items:EntityItem*> "}" => {
        let mut entity = Entity::new(name);
        for item in items {
            match item {
                EntityItem::Field(f) => entity.add_field(f),
                EntityItem::Relation(r) => entity.add_relation(r),
            }
        }
        entity
    }
};

// EntityItem como tipo Rust
EntityItem: EntityItem = {
    <f:Field> => EntityItem::Field(f),
    <r:Relation> => EntityItem::Relation(r),
};

// Field definition
Field: Field = {
    <name:Ident> ":" <ft:FieldType> <mods:FieldModifier*> <backend:BackendAnnotation?> "," => {
        let mut field = Field {
            name,
            field_type: ft,
            nullable: false,
            unique: false,
            primary_key: false,
            default: None,
            backend: backend,
        };
        
        for modifier in mods {
            match modifier {
                FieldModifier::Primary => field.primary_key = true,
                FieldModifier::Unique => field.unique = true,
                FieldModifier::Nullable => field.nullable = true,
                FieldModifier::Default(v) => field.default = Some(v),
            }
        }
        
        field
    }
};

FieldModifier: FieldModifier = {
    "primary" => FieldModifier::Primary,
    "unique" => FieldModifier::Unique,
    "nullable" => FieldModifier::Nullable,
    "default" <d:DefaultValue> => FieldModifier::Default(d),
};

FieldType: FieldType = {
    "uuid" => FieldType::UUID,
    "string" => FieldType::String,
    "int" => FieldType::Int,
    "decimal" => FieldType::Decimal,
    "bool" => FieldType::Bool,
    "timestamp" => FieldType::Timestamp,
    "float" => FieldType::Float,
    "vector" "(" <n:NumericLit> ")" => FieldType::Vector(n),
    "[" <inner:FieldType> "]" => FieldType::Array(Box::new(inner)),
};

DefaultValue: DefaultValue = {
    "now()" => DefaultValue::Now,
    "uuid_v4()" => DefaultValue::UUIDv4,
    <s:StringLit> => DefaultValue::Literal(s),
};

// Relation definition
Relation: Relation = {
    <name:Ident> ":" "[" <target:Ident> "]" "via" <fk:Ident> "," => {
        Relation {
            name,
            kind: RelationKind::HasMany,
            target_entity: target,
            foreign_key: Some(fk),
            through: None,
        }
    },
    
    <name:Ident> ":" <target:Ident> "," => {
        Relation {
            name,
            kind: RelationKind::BelongsTo,
            target_entity: target,
            foreign_key: None,
            through: None,
        }
    },
};

// Backend Annotations
BackendAnnotation: BackendAnnotation = {
    "@cache" => BackendAnnotation::Cache,
    "@olap" => BackendAnnotation::OLAP,
    "@vector" => BackendAnnotation::Vector,
    "@ml" => BackendAnnotation::ML,
};

// Tokens bÃ¡sicos
Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();
NumericLit: usize = r"[0-9]+" => <>.parse::<usize>().unwrap();

StringLit: String = r#""([^"\\]|\\.)*""# => {
    let s = <>;
    s[1..s.len()-1].to_string()
};