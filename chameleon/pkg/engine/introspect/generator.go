package introspect

import (
	"fmt"
	"strings"

	"github.com/chameleon-db/chameleondb/chameleon/pkg/engine/mutation"
)

// GenerateChameleonSchema converts introspected tables to .cham format
func GenerateChameleonSchema(tables []TableInfo) (string, error) {
	var sb strings.Builder

	sb.WriteString("// Auto-generated by: chameleon introspect\n")
	sb.WriteString("// Review and adjust relations manually\n\n")

	// First pass: entities and fields
	for _, table := range tables {
		entityName := toEntityName(table.Name)
		sb.WriteString(fmt.Sprintf("entity %s {\n", entityName))

		for _, col := range table.Columns {
			fieldType := mapColumnType(col.Type)
			sb.WriteString(fmt.Sprintf("    %s: %s", col.Name, fieldType))

			// Add constraints
			if col.PrimaryKey {
				sb.WriteString(" primary")
			}
			if col.Unique && !col.PrimaryKey {
				sb.WriteString(" unique")
			}
			if col.Nullable {
				sb.WriteString(" nullable")
			}

			sb.WriteString(",\n")
		}

		sb.WriteString("}\n\n")
	}

	// Second pass: comments about foreign keys (manual review needed)
	hasFK := false
	for _, table := range tables {
		for _, col := range table.Columns {
			if col.ForeignKey != nil && !hasFK {
				sb.WriteString("// Foreign key relationships (add to entity definitions):\n")
				hasFK = true
			}
			if col.ForeignKey != nil {
				sourceEntity := toEntityName(table.Name)
				targetEntity := toEntityName(col.ForeignKey.ReferencedTable)
				sb.WriteString(fmt.Sprintf(
					"//   %s.%s: [%s] via %s,\n",
					sourceEntity,
					col.Name,
					targetEntity,
					col.Name,
				))
			}
		}
	}

	return sb.String(), nil
}

// mapColumnType converts SQL type to ChameleonDB type
func mapColumnType(sqlType string) string {
	// PostgreSQL types mapping
	typeMap := map[string]string{
		"uuid":                     "uuid",
		"text":                     "string",
		"varchar":                  "string",
		"character varying":        "string",
		"integer":                  "int",
		"bigint":                   "int",
		"smallint":                 "int",
		"decimal":                  "decimal",
		"numeric":                  "decimal",
		"real":                     "float",
		"double precision":         "float",
		"boolean":                  "bool",
		"timestamp":                "timestamp",
		"timestamp with time zone": "timestamp",
		"date":                     "timestamp",
	}

	if mapped, ok := typeMap[sqlType]; ok {
		return mapped
	}

	// Default fallback
	return "string"
}

// toEntityName converts table name to entity name
// users -> User, user_posts -> UserPost
func toEntityName(tableName string) string {
	parts := strings.Split(tableName, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}

	if len(parts) > 0 {
		lastIdx := len(parts) - 1
		parts[lastIdx] = mutation.SingularizeName(parts[lastIdx])
	}

	return strings.Join(parts, "")
}
